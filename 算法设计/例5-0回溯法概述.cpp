//回溯法最重要的概念是：解空间树
//解空间树有两种：子集树和排列数。
//当时讲课的顺序是：先将子集树全部题目，再返回来讲排列树题目。观看ppt要注意顺序。
//
//
//【子集树】：最经典的就是【求幂集的解空间树】。（ppt5页）从最初的空集开始，【每一层代表处理一个元素】；
//左子树代表选择该元素，右子树代表不选。n个元素的集合，最后一层是当然是2^n个结点了。
//这也正是含n个元素的集合的幂集个数！


//【排列树】：最经典的就是【求全排列】。（ppt35页）最初的排列开始，【第i层代表处理第i个元素】；
//几个子树分别代表：和a【i】交换（和自己交换就是不交换）。所以排列中有几个元素，第一层就有几个分支；
//第i层要处理的第i个元素，都是和从i开始（也就是不换）往后的元素换；每一个共父结点群，第一个节点都和父亲节点一样！
//后面每下一层少一个分支。（第i个元素不和第i-1个元素换，防止换回去，即回到上一层的状态）
//来个框架：
void dfs(int a[], int n, int i)		//求a[0..n-1]的全排列
{
    if (i >= n)				//递归出口
        dispasolution(a, n);
    else
    {
        for (int j = i; j < n; j++)
        {
            swap(a[i], a[j]);		//交换a[i]与a[j]:每一个元素只与自己及其后面的元素交换
            dfs(a, n, i + 1);
            swap(a[i], a[j]);		//交换a[i]与a[j]：若没有找到解，恢复
        }
    }
}




//回溯法：
//在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点（开始结点）出发搜索解空间树。
//当从状态si搜索到状态si + 1后，如果si + 1变为死结点，则从状态si + 1回退到si，
//再从si找其他可能的路径，所以回溯法体现出【走不通就退回】再走的思路。

//回溯法搜索解空间时，通常采用两种策略避免无效搜索，提高回溯的搜索效率:
//用【约束函数】在扩展结点处剪除不满足约束的子树；
//用【限界函数】剪去得不到问题解或最优解的子树。
//这两类函数统称为【剪枝】函数。

//归纳起来，用回溯法解题的一般步骤如下：
//确定问题的解空间树，问题的解空间树应至少包含问题的一个（最优）解。
//确定结点的扩展规则。
//以【深度优先方式】搜索解空间树，并在搜索过程中可以采用剪枝函数来避免无效搜索。
//【回溯法 = 深度优先搜索  +  剪枝】

//【活结点】（活结点是指自身已生成但其孩子结点没有全部生成的结点），
//同时也是当前的【扩展结点】（扩展结点是指正在产生孩子结点的结点）。　
//【死结点】（死结点是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕）


//非递归的回溯法框架
//int x[n];				//x存放解向量，全局变量
//void backtrack(int n)			//非递归框架
//{
//	int i = 1;				//根结点层次为1
//	while (i >= 1)			//尚未回溯到头
//	{
//		if (ExistSubNode(t))       //当前结点存在子结点
//		{
//			for (j = 下界; j <= 上界; j++)	//对于子集树，j=0到1循环
//			{
//				x[i]取一个可能的值;
//				if (constraint(i) && bound(i))
//					//x[i]满足约束条件或界限函数
//				{
//					if (x是一个可行解)
//						输出x;
//					else	i++;		//进入下一层次
//				}
//			}
//		}
//		else  i--;			//回溯：不存在子结点，返回上一层
//	}
//}


//递归的回溯法框架
//1.解空间为子集树
//int x[n];			   //x存放解向量，全局变量
//void backtrack(int i)		   //求解子集树的递归框架
//{
//	if (i > n)			   //搜索到叶子结点,输出一个可行解
//		输出结果;
//	else
//	{
//		for (j = 下界; j <= 上界; j++)   //用j枚举i所有可能的路径
//		{
//			x[i] = j;		   //产生一个可能的解分量
//			…			   //其他操作
//				if (constraint(i) && bound(i))
//					backtrack(i + 1);	   //满足约束条件和限界函数,继续下一层
//		}
//	}
//}


























