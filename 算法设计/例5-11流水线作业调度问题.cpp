#include<iostream>
#include<vector>
#include<algorithm>
#include<stdio.h>
#include <queue>
using namespace std;

//【问题描述】有n个作业（编号为1～n）要在由两台机器M1和M2组成的流水线上完成加工。
//每个作业加工的顺序都是先在M1上加工，然后在M2上加工。
//M1和M2加工作业i所需的时间分别为ai和bi（1≤i≤n）。
//
//流水作业调度问题要求确定这n个作业的最优加工顺序，使得从第一个作业在机器M1上开始加工，
//到最后一个作业在机器M2上加工完成所需的时间最少。
//可以假定任何作业一旦开始加工，就不允许被中断，直到该作业被完成，即非优先调度。

//【输入格式】输入包含若干个用例。每个用例第一行是作业数n（1≤n≤1000），
//接下来n行，每行两个非负整数，第i行的两个整数分别表示在第i个作业在第一台机器和第二台机器上加工时间。以输入n = 0结束。
//【输出格式】每个用例输出一行，表示采用最优调度所用的总时间，即从第一台机器开始到第二台机器结束的时间。
//ppt127页！

//符号表示
//作业的编号是1～n。
//数组x[]作为解向量即调度方案，即x[i]表示第i步执行的作业编号，初始时数组x的元素分别是1～n。
//最优解向量用bestx[]存储。
//最优解的最优调度时间用bestf表示。
//
//f1数组：f1[i]表示第i步执行的作业x[i]在M1上执行完的总时间（含前面作业的执行时间）不过发现第一个机器上不用等，
//所以不用数组表示、直接用单个变量f1表示,不停+=就好
//f2数组： f2[i]表示第i步执行的作业x[i]在M2上执行完的总时间（含前面作业的执行时间）
//由于一个作业总是先在M1上执行后在M2执行，所以f2[n]就是执行全部作业的总时间。
//ppt132页
//f2[i]，如果该进程不等，就是f1[i]+b[i];如果该进程要等，那就是f2[i-1]+b[i]

int n=4;
int bestf = 9999;
int f1 = 0;
int f2[] = {0,0,0,0,0};
int x[] = { 0,1,2,3,4 };//默认顺序执行，不用0
int bestx[] = { 0,0,0,0,0 }; //  最佳解向量不参与算法，只是最后用于复制x[]，故初值是多少都没关系
int a[] = {0,5,12,4,8};
int b[] = {0,6,2,14,7};
//以上样例测试数据：ppt137页


void dfs(int i)			//从第i层开始搜索
{
    if (i > n)				//到达叶结点,产生一种调度方案
    {
        if (f2[n] < bestf)		//找到更优解
        {
            bestf = f2[n];
            for (int j = 1; j <= n; j++)	//复制解向量
                bestx[j] = x[j];
        }
    }
    else
    {
        for (int j = i; j <= n; j++)		//没有到达叶结点,考虑可能的作业
        {
            swap(x[i], x[j]);
            f1 += a[x[i]];		//选择作业x[i],在M1上执行完的时间
            f2[i] = max( f1, f2[i - 1] ) + b[x[i]];
            if (f2[i] < bestf)		//剪枝
                dfs(i + 1);
            f1 -= a[x[i]];		//回溯；为啥不回溯f2：因为下次循环它会被重新覆盖
            swap(x[i], x[j]);
        }
    }
}
//进一步剪枝：
int bound(int i)			//求结点的下界值
{
    int sum = 0;
    for (int j = 1; j <= i; j++)		//扫描所有选择的作业
        sum += b[x[j]];			//累计所有选择作业的b时间
    return f2[i] + tot - sum;		//全部n个作业的b时间和为tot
}

void dfs(int i)			//从第i层开始搜索
{
    if (i > n)				//到达叶结点,产生一种调度方案
    {
        if (f2[n] < bestf)		//找到更优解
        {
            bestf = f2[n];
            for (int j = 1; j <= n; j++)	//复制解向量
                bestx[j] = x[j];
        }
    }
    else
    {
        for (int j = i; j <= n; j++)		//没有到达叶结点,考虑可能的作业
        {
            swap(x[i], x[j]);
            f1 += a[x[i]];		//选择作业x[i],在M1上执行完的时间
            f2[i] = max(f1, f2[i - 1]) + b[x[i]];
            if (bound(i) < bestf)		//剪枝
                dfs(i + 1);
            f1 -= a[x[i]];		//回溯
            swap(x[i], x[j]);
        }
    }
}




