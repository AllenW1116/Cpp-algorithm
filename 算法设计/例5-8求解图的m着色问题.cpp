#include<iostream>
#include<vector>
#include<algorithm>
#include<stdio.h>

//【问题描述】给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点着色，
//每个顶点着一种颜色。如果有一种着色法使G中每条边的两个顶点着不同颜色，
//则称这个图是m可着色的。图的m着色问题是对于给定图G和m种颜色，找出所有不同的着色法。
//
//【输入格式】第1行有3个正整数n、k和m，表示给定的图G有n个顶点和k条边，m种颜色。
//顶点编号为1，2，…，n。接下来的k行中，每行有两个正整数u、v，表示图G的一条边（u，v）。
//
//【输出格式】程序运行结束时，将计算出的不同的着色方案数输出。如果不能着色，程序输出 - 1。

//【问题求解】对于图G，采用邻接矩阵a存储，根据求解问题需要，
//这里a为一个二维数组（下标0不用），当顶点i与顶点j有边时，置a[i][j] = 1，其他情况置a[i][j] = 0。
//图中的顶点编号为1～n，着色编号为1～m。对于图G中的每一个顶点，可能的着色为1～m，所以对应的解空间是一棵m叉树，高度为n，层次i从1开始。

//
//【输入样例】
//5 8 4
//1 2
//1 3
//1 4
//2 3
//2 4
//2 5
//3 4
//4 5
//【输出样例】
//48

int sum = 0;//着色方案数，初始值0
int n = 5, k = 8, m = 4;//定点数 边数 颜色数
int a[5][5] = {//存放邻接矩阵
    {0,1,1,1,0},
    {1,0,1,1,1},
    {1,1,0,1,0},
    {1,1,1,0,1},
    {0,1,0,1,0}
};
int x[5];//存放顶点颜色


bool Same(int i)	//判断顶点i是否与相邻顶点存在相同的着色
{
    for (int j = 0; j <= n; j++)
        if (a[i][j] == 1 && x[i] == x[j])
            return false;
    return true;
}
void dfs(int i)		//求解图的m着色问题 i的传入值为0
{
    if (i >= n)			//达到叶子结点
        sum++;			//着色方案数增1
    else
    {
        for (int j = 1; j <= m; j++)	//试探每一种着色
        {
            x[i] = j;		//试探着色j
            if (Same(i))		//可以着色j，进入下一个顶点着色
                dfs(i + 1);
            x[i] = 0;		//回溯
        }
    }
}
//本算法就是按照节点序号递增来着色的；即使12之间没有边，涂完1也要涂2！

