#include<iostream>
#include<vector>
#include<algorithm>
#include<stdio.h>
#include <queue>
using namespace std;
//分枝限界法类似于回溯法，也是一种在问题的解空间树上搜索问题解的算法。
//但在一般情况下，分枝限界法与回溯法的求解目标不同。
//回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分枝限界法的求解目标则是找出满足约束条件的一个解，
//或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的【最优解】。
//回溯法vs分支界限法：ppt第4页！
//分支界限【广度优先】 回溯法【深度优先】
//所以在分支界限法中，很重要的一点是：如何使用【队列】和【优先队列】组织活结点！

//（1）队列式分枝限界法
//队列式分枝限界法将活结点表组织成一个队列，并按照队列先进先出（FIFO）原则选取下一个结点为扩展结点。步骤如下：
//将根结点加入活结点队列。
//从活结点队中取出队头结点，作为当前扩展结点。
//对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子结点加入活结点队列。
//重复步骤②和③，直到找到一个解或活结点队列为空为止。
//
//2）优先队列式分枝限界法
//优先队列式分枝限界法的主要特点是将活结点表组组成一个优先队列，并选取优先级最高的活结点成为当前扩展结点。步骤如下：
//计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。
//从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推进，以便尽快地找出一个最优解。
//对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的孩子结点计算优先级并加入优先队列。
//重复步骤②和③，直到找到一个解或优先队列为空为止。

//实现方法：对每个扩展结点保存从根结点到该结点的路径。
//【每个结点带有一个可能的解向量】。这种做法比较浪费空间，但实现起来简单，后面的示例均采用这种方式。

