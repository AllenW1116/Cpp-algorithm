#include<iostream>
#include<vector>
#include<algorithm>
#include<stdio.h>
#include <queue>		
using namespace std;
//求解蓄栏保留问题。农场有n头牛，每头牛会有一个特定的时间区间[b，e]在蓄栏里挤牛奶，并且一个蓄栏里任何时刻只能有一头牛挤奶。
//现在农场主希望知道最少蓄栏能够满足上述要求，并给出每头牛被安排的方案。对于多种可行方案，输出一种即可。

//牛的编号为1～n，每头牛的挤奶时间相当于一个活动，与前面活动安排问题不同，
//这里的活动时间是闭区间，例如[2，4]与[4，7]是交叉的，它们不是兼容活动。
//采用与求解活动安排问题类似的贪心思路，将所有活动这样排序：结束时间相同按开始时间递增排序，否则按结束时间递增排序。
//求出一个最大兼容活动子集，将它们安排在一个蓄栏中（蓄栏编号为1）；
//如果没有安排完，再在剩余的活动再求下一个最大兼容活动子集，将它们安排在另一个蓄栏中（蓄栏编号为2），以此类推。
//也就是说，最大兼容活动子集的个数就是最少蓄栏个数。
//示例解决：ppt19页！



//问题表示
struct Cow			//奶牛的类型声明
{
    int no;			//牛编号
    int b;			//起始时间
    int e;			//结束时间
    bool operator<(const Cow& s) const   //重载<关系函数
    {
        if (e == s.e)		//结束时间相同按开始时间递增排序
            return b <= s.b;
        else			//否则按结束时间递增排序
            return e <= s.e;
    }
};
int n = 5;
Cow A[] = { {0},{1,1,10},{2,2,4},{3,3,6},{4,5,8},{5,4,7} };
//下标0不用
//求解结果表示
int ans[MAX];			//ans[i]表示第A[i].no头牛的蓄栏编号
//最终结果应该是：{0，4，1，2，1，3}见ppt23页

void solve()				//求解最大兼容活动子集个数
{
    sort(A + 1, A + n + 1);			//A[1..n]按指定方式排序
    memset(ans, 0, sizeof(ans));		//初始化为0
    int num = 1;				//蓄栏编号
    for (int i = 1; i <= n; i++)		//i、j均为排序后的下标
    {
        if (ans[i] == 0)			//第i头牛还没有安排蓄栏
        {
            ans[i] = num;			//第i头牛安排蓄栏num
            int preend = A[i].e;		//前一个兼容活动的结束时间
            for (int j = i + 1; j <= n; j++)	//查找一个最大兼容活动子集
            {
                if (A[j].b > preend && ans[j] == 0) //ans【】=0说明该牛还未分配畜栏
                {
                    ans[j] = num;	//将兼容活动子集中活动安排在num蓄栏中
                    preend = A[j].e;		//更新结束时间
                }
            }
            num++;		//查找下一个最大兼容活动子集,num增1
        }
    }
}
