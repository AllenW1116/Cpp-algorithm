#include<iostream>
#include<algorithm>
using namespace std;
//曾经我们使用递归方法解决斐波那契数列时：
//（1）求解Fib(5)
//（2）求解Fib(4)
//（3）求解Fib(3)
//（4）求解Fib(2)
//计算出Fib(2) = 1
//（5）求解Fib(1)
//计算出Fib(1) = 1
//计算出Fib(3) = Fib(2) + Fib(1) = 2
//（6）求解Fib(2)
//计算出Fib(2) = 1
//计算出Fib(4) = Fib(3) + Fib(2) = 3
//（7）求解Fib(3)
//（8）求解Fib(2)
//计算出Fib(2) = 1
//（9）求解Fib(1)
//计算出Fib(1) = 1
//计算出Fib(3) = Fib(2) + Fib(1) = 2
//计算出Fib(5) = Fib(4) + Fib(3) = 5
//可以看出，我们是自顶向下的在解决问题，不可避免地，有很多值我们是重复计算的。
//若使用动态规划：
//
//int dp[MAX];				//所有元素初始化为0
//int count = 1;				//累计调用的步骤
//int Fib1(int n)			//算法1
//{
//    dp[1] = dp[2] = 1;
//    printf("(%d)计算出Fib(1)=1\n"，count++);
//    printf("(%d)计算出Fib(2)=1\n"，count++);
//    for (int i = 3; i <= n; i++)
//    {
//        dp[i] = dp[i - 1] + dp[i - 2];
//        printf("(%d)计算出Fib(%d)=%d\n"，count++，i，dp[i]);
//    }
//    return dp[n];
//}
//
//输出结果：
//（1）计算出Fib1(1) = 1
//（2）计算出Fib1(2) = 1
//（3）计算出Fib1(3) = 2
//（4）计算出Fib1(4) = 3
//（5）计算出Fib1(5) = 5
//
//避免了重复计算，并且问题变成了【由下至上】的解决方法
//该方法最大的特点，在于【将曾经的结果存储下来供以后利用】
//所以动态规划法又称【结果存储再利用法】

//ppt10页：动态规划铺设管道实例！
//逆序求解：f（s）指当前结点s到终点的距离；
//顺序求解：f（s）指当前结点s到起点的距离；





